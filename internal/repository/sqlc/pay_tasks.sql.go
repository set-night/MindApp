// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pay_tasks.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const checkPayTaskCompletion = `-- name: CheckPayTaskCompletion :one
SELECT EXISTS(
    SELECT 1 FROM pay_task_completions WHERE task_id = $1 AND user_id = $2
) AS completed
`

type CheckPayTaskCompletionParams struct {
	TaskID int64 `json:"task_id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) CheckPayTaskCompletion(ctx context.Context, arg CheckPayTaskCompletionParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkPayTaskCompletion, arg.TaskID, arg.UserID)
	var completed bool
	err := row.Scan(&completed)
	return completed, err
}

const createPayTaskCompletion = `-- name: CreatePayTaskCompletion :exec
INSERT INTO pay_task_completions (task_id, user_id) VALUES ($1, $2)
`

type CreatePayTaskCompletionParams struct {
	TaskID int64 `json:"task_id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) CreatePayTaskCompletion(ctx context.Context, arg CreatePayTaskCompletionParams) error {
	_, err := q.db.Exec(ctx, createPayTaskCompletion, arg.TaskID, arg.UserID)
	return err
}

const getAvailablePayTasks = `-- name: GetAvailablePayTasks :many
SELECT pt.id, pt.title, pt.telegram_link, pt.channel_id, pt.reward, pt.time_limit, pt.max_people, COUNT(ptc.id)::int AS completed_count
FROM pay_tasks pt
LEFT JOIN pay_task_completions ptc ON ptc.task_id = pt.id
WHERE (pt.time_limit IS NULL OR pt.time_limit > NOW())
GROUP BY pt.id
HAVING (pt.max_people IS NULL OR COUNT(ptc.id) < pt.max_people)
`

type GetAvailablePayTasksRow struct {
	ID             int64              `json:"id"`
	Title          string             `json:"title"`
	TelegramLink   string             `json:"telegram_link"`
	ChannelID      string             `json:"channel_id"`
	Reward         decimal.Decimal    `json:"reward"`
	TimeLimit      pgtype.Timestamptz `json:"time_limit"`
	MaxPeople      *int32             `json:"max_people"`
	CompletedCount int32              `json:"completed_count"`
}

func (q *Queries) GetAvailablePayTasks(ctx context.Context) ([]GetAvailablePayTasksRow, error) {
	rows, err := q.db.Query(ctx, getAvailablePayTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailablePayTasksRow{}
	for rows.Next() {
		var i GetAvailablePayTasksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.TelegramLink,
			&i.ChannelID,
			&i.Reward,
			&i.TimeLimit,
			&i.MaxPeople,
			&i.CompletedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailablePayTasksForUser = `-- name: GetAvailablePayTasksForUser :many
SELECT pt.id, pt.title, pt.telegram_link, pt.channel_id, pt.reward, pt.time_limit, pt.max_people, COUNT(ptc.id)::int AS completed_count
FROM pay_tasks pt
LEFT JOIN pay_task_completions ptc ON ptc.task_id = pt.id
WHERE (pt.time_limit IS NULL OR pt.time_limit > NOW())
  AND pt.id NOT IN (SELECT ptc2.task_id FROM pay_task_completions ptc2 WHERE ptc2.user_id = $1)
GROUP BY pt.id
HAVING (pt.max_people IS NULL OR COUNT(ptc.id) < pt.max_people)
`

type GetAvailablePayTasksForUserRow struct {
	ID             int64              `json:"id"`
	Title          string             `json:"title"`
	TelegramLink   string             `json:"telegram_link"`
	ChannelID      string             `json:"channel_id"`
	Reward         decimal.Decimal    `json:"reward"`
	TimeLimit      pgtype.Timestamptz `json:"time_limit"`
	MaxPeople      *int32             `json:"max_people"`
	CompletedCount int32              `json:"completed_count"`
}

func (q *Queries) GetAvailablePayTasksForUser(ctx context.Context, userID int64) ([]GetAvailablePayTasksForUserRow, error) {
	rows, err := q.db.Query(ctx, getAvailablePayTasksForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailablePayTasksForUserRow{}
	for rows.Next() {
		var i GetAvailablePayTasksForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.TelegramLink,
			&i.ChannelID,
			&i.Reward,
			&i.TimeLimit,
			&i.MaxPeople,
			&i.CompletedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPayTaskByID = `-- name: GetPayTaskByID :one
SELECT pt.id, pt.title, pt.telegram_link, pt.channel_id, pt.reward, pt.time_limit, pt.max_people, COUNT(ptc.id)::int AS completed_count
FROM pay_tasks pt
LEFT JOIN pay_task_completions ptc ON ptc.task_id = pt.id
WHERE pt.id = $1
GROUP BY pt.id
`

type GetPayTaskByIDRow struct {
	ID             int64              `json:"id"`
	Title          string             `json:"title"`
	TelegramLink   string             `json:"telegram_link"`
	ChannelID      string             `json:"channel_id"`
	Reward         decimal.Decimal    `json:"reward"`
	TimeLimit      pgtype.Timestamptz `json:"time_limit"`
	MaxPeople      *int32             `json:"max_people"`
	CompletedCount int32              `json:"completed_count"`
}

func (q *Queries) GetPayTaskByID(ctx context.Context, id int64) (GetPayTaskByIDRow, error) {
	row := q.db.QueryRow(ctx, getPayTaskByID, id)
	var i GetPayTaskByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.TelegramLink,
		&i.ChannelID,
		&i.Reward,
		&i.TimeLimit,
		&i.MaxPeople,
		&i.CompletedCount,
	)
	return i, err
}
